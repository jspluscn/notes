## 4.5 [基本类型和运算符](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.5.md)

每个类型都定义了可以和自己结合的运算符集合，如果你使用了不在这个集合中的运算符，则会在编译时获得编译错误

一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）

只有两个类型相同的值才可以和二元运算符结合，另外要注意的是，Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明（第 4.2 节）


Go 对于值之间的比较有非常严格的限制:

- 只有两个类型相同的值才可以进行比较
- 如果值的类型是接口（`interface`，第 11 章），它们也必须都实现了相同的接口
- 如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。
- 如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。

### 4.5.1 布尔类型 bool

`true` `false`

`==` `!=` `!` `&&` `||` (只有`!`是一元操作符)

`&&` 和 `||` 是具有快捷性质的运算符 (若左边已经有结果，那么右边不再计算)

`%t` 表示要输出的值为布尔型

对于布尔值的好的命名能够很好地提升代码的可读性，例如以 `is` 或者 `Is` 开头的 `isSorted`、`isFinished`、`isVisible`

### 4.5.2 数字类型

#### 4.5.2.1 整型 int 和浮点型 float

Go 也有基于架构的类型，例如：`int`、`uint` 和 `uintptr`。

这些类型的长度都是根据运行程序所在的操作系统类型所决定的：

- `int` 和 `uint` 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。
- `uintptr` 的长度被设定为足够存放一个指针即可。

Go 语言中没有 `float` 类型。

与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：

整数：
```go
int8 （-128 -> 127）
int16（-32768 -> 32767）
int32（-2,147,483,648 -> 2,147,483,647）
int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）
```
无符号整数：
```go
uint8 （0 -> 255）
uint16（0 -> 65,535）
uint32（0 -> 4,294,967,295）
uint64（0 -> 18,446,744,073,709,551,615）
```
浮点型（IEEE-754 标准）：
```go
// float32 精确到小数点后 7 位，float64 精确到小数点后 15 位
float32（+- 1e-45 -> +- 3.4 * 1e38）
float64（+- 5 * 1e-324 -> 107 * 1e308）
```

`int` 型是计算最快的一种类型。

整型的零值为 0，浮点型的零值为 0.0。(zero value)

你应该尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。

你可以通过增加前缀 0 来表示 8 进制数（如：`077`）

增加前缀 0x 来表示 16 进制数（如：`0xFF`）

以及使用 e 来表示 10 的连乘（如： `1e3 = 1000`，或者 `6.022e23 = 6.022 x 1e23`）。

**格式化说明符**

`%d` 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字）

`%g` 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法）

`%0d` 用于规定输出定长的整数，其中开头的数字 0 是必须的。

`%n.mg` 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00。

**数字值转换**

当进行类似 a32bitInt = int32(a32Float) 的转换时，小数点后的数字将被丢弃

可以自己写一个函数实现四舍五入

#### 4.5.2.2 复数

Go 拥有以下复数类型：
```go
complex64 (32 位实数和虚数)
complex128 (64 位实数和虚数)
```
复数使用 `re+imI` 来表示，其中 `re` 代表实数部分，`im` 代表虚数部分，`I` 代表`根号负 1`。

示例：
```go
var c1 complex64 = 5 + 10i
fmt.Printf("The value is: %v", c1)
// 输出： 5 + 10i
```

如果 `re` 和 `im` 的类型均为 `float32`，那么类型为 `complex64` 的复数 `c` 可以通过以下方式来获得：
```go
c = complex(re, im)
```
函数 `real(c)` 和 `imag(c)` 可以分别获得相应的实数和虚数部分。

在使用格式化说明符时，可以使用 `%v` 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 `%f`

cmath 包中包含了一些操作复数的公共方法。

如果你对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数

#### 4.5.2.3 位运算

位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。(对应位置上的值经过计算结果)

`%b` 是用于表示位的格式化标识符。

**二元运算符**

- 按位与 `&`：

对应位置上的值经过和运算结果，具体参见和运算符，第 4.5.1 节，并将 T（true）替换为 1，将 F（false）替换为 0
```
  1 & 1 -> 1
  1 & 0 -> 0
  0 & 1 -> 0
  0 & 0 -> 0
```

- 按位或 `|`：

对应位置上的值经过或运算结果，具体参见或运算符，第 4.5.1 节，并将 T（true）替换为 1，将 F（false）替换为 0
```
  1 | 1 -> 1
  1 | 0 -> 1
  0 | 1 -> 1
  0 | 0 -> 0
```

- 按位异或 `^`：

对应位置上的值根据以下规则组合：
```
  1 ^ 1 -> 0
  1 ^ 0 -> 1
  0 ^ 1 -> 1
  0 ^ 0 -> 0
```
- 位清除 `&^`：将指定位置上的值设置为 0。

**一元运算符**

- 按位补足 `^`：

该运算符与异或运算符一同使用，即 m^x，对于无符号 x 使用“全部位设置为 1”，对于有符号 x 时使用 m=-1。例如：

  ^2 = ^10 = -01 ^ 10 = -11

- 位左移 <<：

  - 用法：`bitP << n`。
  - 即 2 的 n 次方
  - bitP 的位向左移动 n 位，右侧空白部分使用 0 填充

```
  1 << 10 // 等于 1 KB
  1 << 20 // 等于 1 MB
  1 << 30 // 等于 1 GB
```

- 位右移 >>：

  - 用法：bitP >> n。
  - 即当前值除以 2 的 n 次方
  - bitP 的位向右移动 n 位，左侧空白部分使用 0 填充

当希望把结果赋值给第一个操作数时，可以简写为 a <<= 2 或者 b ^= a & 0xffffffff

**位左移常见实现存储单位的用例**

使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：

```go
type ByteSize float64
const (
	_ = iota // 0被跳过
	KB ByteSize = 1<<(10*iota)
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)
```

**在通讯中使用位左移表示标识的用例**

```go
type BitFlag int
const (
	Active BitFlag = 1 << iota // 1 << 0 == 1
	Send // 1 << 1 == 2
	Receive // 1 << 2 == 4
)

flag := Active | Send // == 3
```

#### 4.5.2.4 逻辑运算符

Go 中拥有以下逻辑运算符：`==`、`!=`（第 4.5.1 节）、`<`、`<=`、`>`、`>=`。

它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool。例如：
```go
b3:= 10 > 5 // b3 is true
```

#### 4.5.2.5 算术运算符

常见可用于整数和浮点数的二元运算符有 `+`、`-`、`*` 和 `/`。

（相对于一般规则而言，Go 在进行字符串拼接时允许使用对运算符 `+` 的重载，但 Go 本身不允许开发者进行自定义的运算符重载）

`/` 对于整数运算而言，结果依旧为整数，例如：`9 / 4 -> 2`。

取余运算符只能作用于整数：`9 % 4 -> 1`。

整数除以 0 可能导致程序崩溃，将会导致`panic`（如果除以 0 的行为在编译时就能被捕捉到，则会引发编译错误）

浮点数除以 0.0 会返回一个无穷尽的结果，使用 +Inf 表示。

你可以将语句 b = b + a 简写为 b+=a，同样的写法也可用于 `-=`、`*=`、`/=`、`%=`。

对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀：

带有 ++ 和 -- 的只能作为语句，而非表达式，因此 `n = i++` / `f(i++)` / `a[i]=b[i++]` 是不允许的

**在运算时 溢出 不会产生错误，Go 会简单地将超出位数抛弃。**

如果你需要范围无限大的整数或者有理数（意味着只被限制于计算机内存），你可以使用标准库中的 `big` 包，该包提供了类似 `big.Int` 和 `big.Rat` 这样的类型

#### 4.5.2.6 随机数

一些像游戏或者统计学类的应用需要用到随机数。rand 包实现了伪随机数的生成。

演示了如何生成 10 个非负随机数：
```go
rand.Int()

rand.Intn(8)

rand.Float32()
```

你可以使用 `rand.Seed(int64(time.Now().Nanosecond()))` 函数来提供伪随机数的生成种子，一般情况下都会使用当前时间的纳秒级数字

#### 4.5.3 运算符与优先级

有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：
```go
优先级 	运算符
 7 		^ !
 6 		* / % << >> & &^
 5 		+ - | ^
 4 		== != < <= >= >
 3 		<-
 2 		&&
 1 		||
 ```

#### 4.5.4 类型别名

当你在使用某个类型时，你可以给它起另一个名字，然后你就可以在你的代码中使用新的名字（用于简化名称或解决名称冲突）。

在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。

示例 4.11 type.go
```go
package main
import "fmt"

type TZ int

func main() {
	var a, b TZ = 3, 4
	c := a + b
	fmt.Printf("c has the value: %d", c) // 输出：c has the value: 7
}
```
实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法（第 10 章）；TZ 可以自定义一个方法用来输出更加人性化的时区信息。

练习 4.5 定义一个 string 的类型别名 Rope，并声明一个该类型的变量。

#### 4.5.5 字符类型

严格来说，这并不是 Go 语言的一个类型，字符只是整数的特殊用例。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：var ch byte = 'A'；字符使用单引号括起来。

在 ASCII 码表中，A 的值是 65，而使用 16 进制表示则为 41，所以下面的写法是等效的：

var ch byte = 65 或 var ch byte = '\x41'
（\x 总是紧跟着长度为 2 的 16 进制数）

另外一种可能的写法是 \ 后面紧跟着长度为 3 的八进制数，例如：\377。

不过 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。其实 rune 也是 Go 当中的一个类型，并且是 int32 的别名。

在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \u 或者 \U。

因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \U 前缀；前缀 \u 则总是紧跟着长度为 4 的 16 进制数，前缀 \U 紧跟着长度为 8 的 16 进制数。

示例 4.12 char.go
```go
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
fmt.Printf("%U - %U - %U", ch, ch2, ch3) // UTF-8 code point
```
输出：
```go
65 - 946 - 1053236
A - β - r
41 - 3B2 - 101234
U+0041 - U+03B2 - U+101234
```
格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。

包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）：

- 判断是否为字母：unicode.IsLetter(ch)
- 判断是否为数字：unicode.IsDigit(ch)
- 判断是否为空白符号：unicode.IsSpace(ch)

这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。
