## 4.4 [变量](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.4.md)

### 4.4.1 简介

声明变量的一般形式是使用 `var` 关键字：`var identifier type`。

需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？

首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：`int* a, b`;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写（你可以在 Go 语言的声明语法 页面找到有关于这个话题的更多讨论）。

而在 `Go` 中，则可以很轻松地将它们都声明为指针类型：
```go
var a, b *int
```

其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。

示例：
```go
var a int
var b bool
var str string
```
你也可以改写成这种形式：(**这种因式分解关键字的写法一般用于声明全局变量。**)
```go
var (
	a int
	b bool
	str string
)
```

当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。**记住，所有的内存在 Go 中都是经过初始化的。（什么意思？？？）**

变量的命名规则遵循骆驼命名法

声明与赋值（初始化）语句也可以组合起来。

示例：
```go
var identifier [type] = value
var a int = 15 //Go 编译器可以根据变量的值来自动推断其类型，在编译时就完成
var b = 5
```

不过自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型，例如：
```go
var n int64 = 2
```

然而，`var a` 这种语法是不正确的，因为编译器没有任何可以用于自动推断类型的依据。

变量的类型也可以在运行时实现自动推断，例如：
```go
var (
	HOME = os.Getenv("HOME")
	USER = os.Getenv("USER")
	GOROOT = os.Getenv("GOROOT")
)
```

### 4.4.2 值类型和引用类型

程序中所用到的内存在计算机中使用一堆箱子来表示（这也是人们在讲解它的时候的画法），这些箱子被称为 “ 字 ”。根据不同的处理器以及操作系统类型，所有的字都具有 32 位（4 字节）或 64 位（8 字节）的相同长度；所有的字都使用相关的内存地址来进行表示（以十六进制数表示）。

所有像 int、float、bool 和 string 这些基本类型都属于值类型

像数组（第 7 章）和结构（第 10 章）这些复合类型也是值类型

这个内存地址被称之为指针（你可以从上图中很清晰地看到，第 4.9 节将会详细说明），这个指针实际上也被存在另外的某一个字中。

指针（第 4.9 节）属于引用类型，其它的引用类型还包括 slices（第 7 章），maps（第 8 章）和 channel（第 13 章）

**[详细的见这里！！！](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.4.md#442-值类型和引用类型)**
### 4.4.3 打印
```go
fmt.Printf

fmt.Print

fmt.Println

fmt.Srintf
```
### 4.4.4 简短形式，使用 := 赋值操作符

`:=` 只能被用在函数体内，而不可以用于全局变量的声明与赋值

全局变量是允许声明但不使用，局部变量不能只声明而不使用

同一类型的多个变量可以声明在同一行，`var a, b, c int`

**并行** 或 **同时** 赋值 ： `a, b, c := 5, 7, "abc"`

交换两个变量的值 : `a, b = b, a`

空白标识符 `_` 也被用于抛弃值， `_` 实际上是一个只写变量，你不能得到它的值。（**原因**：这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。）

### 4.4.5 init 函数

变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。

每一个源文件都可以包含一个或多个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。

一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。
