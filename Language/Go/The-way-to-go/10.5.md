## 10.5 [匿名字段和内嵌结构体](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.5.md)

### 10.5.1 定义

结构体可以包含一个或多个 **匿名（或内嵌）字段**，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。

匿名字段本身可以是一个结构体类型，即 **结构体可以包含内嵌结构体**。

可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go 语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go 语言中，相比较于继承，组合更受青睐。

考虑如下的程序：
```go
package main

import "fmt"

type innerS struct {
	in1 int
	in2 int
}

type outerS struct {
	b    int
	c    float32
	int  // 匿名字段
	innerS //anonymous field
}

func main() {
	outer := new(outerS)
	outer.b = 6
	outer.c = 7.5
	outer.int = 60
	outer.in1 = 5
	outer.in2 = 10

	// 使用结构体字面量
	outer2 := outerS{6, 7.5, 60, innerS{5, 10}}
}
通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：**在一个结构体中对于每一种数据类型只能有一个匿名字段**。

### 10.5.2 内嵌结构体

外层结构体通过 outer.in1 直接进入内层结构体的字段。

这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。
```go
package main

import "fmt"

type A struct {
	ax, ay int
}

type B struct {
	A
	bx, by float32
}

func main() {
	b := B{A{1, 2}, 3.0, 4.0}
	fmt.Println(b.A)  // {1, 2}
}
```

### 10.5.3 命名冲突

当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？

- 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；
- 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。
例子：
```go
type A struct {a int}
type B struct {a, b int}

type C struct {A; B}

var c C; // OK，定义未使用
c.a // ERROR
c.B.a // OK
```
