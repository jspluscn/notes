# 7.1 [声明和初始化](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/07.1.md)

## 7.1.1 概念
数组是具有相同 **唯一类型** 的一组已编号且长度固定的数据项序列（这是一种同构的数据结构）；
- 这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。
- 数组长度必须是一个常量表达式，并且必须是一个非负整数。
- **数组长度也是数组类型的一部分** ，所以[5]int和[10]int是属于不同类型的。数组的编译时值初始化是按照数组顺序完成的（如下）。

数组长度最大为 2Gb。

声明数组时所有的元素都会被自动初始化为零值

声明的格式是： 

```go
var identifier [len]type
```

在内存中的结构是：![](https://github.com/Unknwon/the-way-to-go_ZH_CN/raw/master/images/7.1_fig7.1.png?raw=true)

对索引项为 i 的数组元素赋值可以这么操作：`arr[i] = value`，所以数组是 **可变的**。

只有有效的索引可以被使用，当使用等于或者大于 `len(arr1)` 的索引时：如果编译器可以检测到，会给出索引超限的提示信息；如果检测不到的话编译会通过而运行时会 panic:（参考 [第 13 章](13.0.md)）

```go
[...]string{"a", "b", "c", "d"}
```

Go 语言中的数组是一种 **值类型**（不像 C/C++ 中是指向首元素的指针），所以可以通过 `new()` 来创建： `var arr1 = new([5]int)`。

那么这种方式和 `var arr2 [5]int` 的区别是什么呢？arr1 的类型是 `*[5]int`，而 arr2的类型是 `[5]int`。

这样的结果就是当把一个数组赋值给另一个时，需要在做一次数组内存的拷贝操作。例如：

```go
arr2 := *arr1
arr2[2] = 100
```

这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。

所以在函数中数组作为参数传入时，如 `func1(arr2)`，会产生一次数组拷贝，func1 方法不会修改原始的数组 arr2。

如果你想修改原数组，那么 arr2 必须通过&操作符以引用方式传过来，例如 func1(&arr2），下面是一个例子

另一种方法就是生成数组切片并将其传递给函数（详见第 7.1.4 节）。

## 7.1.2 数组常量

如果数组值已经提前知道了，那么可以通过 **数组常量** 的方法来初始化数组，而不用依次使用 `[]=` 方法（所有的组成元素都有相同的常量语法）。

`...` 可同样可以忽略，从技术上说它们其实变化成了切片。

```go
var arrAge = [5]int{18, 20, 15, 22, 16}

var arrLazy = [...]int{5, 6, 7, 8, 22}

var arrKeyValue = [5]string{3: "Chris", 4: "Ron"}
```

## 7.1.3 多维数组

数组通常是一维的，但是可以用来组装成多维数组，例如：`[3][5]int`，`[2][2][2]float64`。

内部数组总是长度相同的。Go 语言的多维数组是矩形式的（唯一的例外是切片的数组，参见第 7.2.5 节）。

## 7.1.4 将数组传递给函数

把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：

- 传递数组的指针
- 使用数组的切片

但这在 Go 中并不常用，通常使用切片（参考 [第 7.2 节](07.2.md)）。

## 链接

- [目录](directory.md)
- 上一节：[数组与切片](07.0.md)
- 下一节：[切片](07.2.md)
